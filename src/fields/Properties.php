<?php

namespace wsydney76\propertiesfield\fields;

use Craft;
use craft\base\ElementInterface;
use craft\base\Field;
use craft\base\RelationalFieldInterface;
use craft\elements\Entry;
use craft\errors\InvalidFieldException;
use craft\helpers\Cp;
use craft\helpers\StringHelper;
use wsydney76\propertiesfield\models\PropertiesModel;
use wsydney76\propertiesfield\PropertiesFieldPlugin;
use yii\db\Schema;
use function array_merge;
use function is_array;
use function is_string;

/**
 * Properties field type
 */
class Properties extends Field implements RelationalFieldInterface
{
    public array $propertiesFieldConfig = [];

    public static function displayName(): string
    {
        return Craft::t('_properties-field', 'Properties');
    }

    public static function icon(): string
    {
        return 'table-list';
    }

    /**
     * @inheritDoc
     */
    public static function phpType(): string
    {
        return PropertiesModel::class;
    }

    public static function dbType(): array|string|null
    {
        // Replace with the appropriate data type this field will store in the database,
        // or `null` if the field is managing its own data storage.
        return Schema::TYPE_JSON;
    }

    protected function dbTypeForValueSql(): array|string|null
    {
        return parent::dbTypeForValueSql(); // TODO: Change the autogenerated stub
    }

    public function attributeLabels(): array
    {
        return array_merge(parent::attributeLabels(), [
            // ...
        ]);
    }

    protected function defineRules(): array
    {
        return array_merge(parent::defineRules(), [

            ['propertiesFieldConfig', 'checkConfig'],

        ]);
    }

    public function checkConfig($attribute): void
    {
        $handles = [];
        foreach ($this->propertiesFieldConfig as $i => $fieldConfig) {

            if (empty($fieldConfig['name'])) {
                $this->addError($attribute, Craft::t('_properties-field', $i + 1 . ': Name cannot be blank.'));
            } else {
                if (empty($fieldConfig['handle'])) {
                    // If handle is empty, use name as handle
                    $fieldConfig['handle'] = StringHelper::slugify($fieldConfig['name']);
                    $this->propertiesFieldConfig[$i]['handle'] = $fieldConfig['handle'];
                }
            }

            if (empty($fieldConfig['handle'])) {
                $this->addError($attribute, Craft::t('_properties-field', $i + 1 . ': Handle cannot be blank.'));
            } elseif (in_array($fieldConfig['handle'], $handles, true)) {
                $this->addError($attribute, Craft::t('_properties-field', $i + 1 . ': Handle must be unique.'));
            } else {
                $handles[] = $fieldConfig['handle'];
            }


            if (!empty($fieldConfig['fieldConfig'])) {
                // Check if fieldConfig is a valid JSON string
                $isValidJson = json_decode($fieldConfig['fieldConfig'], true);
                if ($isValidJson === null) {
                    $this->addError($attribute, Craft::t('_properties-field', $i + 1 . ': Field Config must be a valid JSON string.'));
                }
            }
        }
    }

    /**
     * The HTML for the field settings in the control panel.
     *
     * @return string|null
     */
    public function getSettingsHtml(): ?string
    {
        $settings = PropertiesFieldPlugin::getInstance()->getSettings();

        $options = array_merge($settings->propertiesConfig, $settings->extraPropertiesConfig);
        return Cp::editableTableFieldHtml([
            'label' => Craft::t('_properties-field', 'Properties Configuration'),
            'instructions' => Craft::t('_properties-field', 'Options for select: one option per line, in the format value:label<br>Options for entries/assets: section/volume handles, comma separated'),
            'id' => 'propertiesFieldConfig',
            'name' => 'propertiesFieldConfig',
            'addRowLabel' => Craft::t('_properties-field', 'Add a property'),
            'allowAdd' => true,
            'allowReorder' => true,
            'allowDelete' => true,
            'warning' => Craft::t('_properties-field', 'Renaming an existing option or changing its type may result in data loss or runtime errors without migrating existing content.'),
            'cols' => [
                'name' => ['heading' => Craft::t('_properties-field', 'Name'), 'type' => 'singleline'],
                'handle' => ['heading' => Craft::t('_properties-field', 'Handle'), 'type' => 'singleline', 'class' => 'code'],
                'instructions' => ['heading' => Craft::t('_properties-field', 'Instructions'), 'type' => 'singleline'],
                'required' => ['heading' => Craft::t('_properties-field', 'Required'), 'type' => 'lightswitch'],
                'type' => [
                    'heading' => Craft::t('_properties-field', 'Type'),
                    'type' => 'select',
                    'class' => 'code',
                    'options' => $options,
                    'width' => '10%',
                ],
                'options' => ['heading' => Craft::t('_properties-field', 'Options'), 'type' => 'multiline'],
                'fieldConfig' => ['heading' => Craft::t('_properties-field', 'Field Config'), 'type' => 'multiline'],

            ],
            'rows' => $this->propertiesFieldConfig,
            'errors' => $this->getErrors('propertiesFieldConfig'),
            'data' => ['error-key' => 'options'],
        ]);
    }

    /**
     * @inheritDoc
     */
    public function normalizeValue(mixed $value, ?ElementInterface $element): mixed
    {
        if ($value instanceof PropertiesModel) {
            $value->propertiesFieldConfig = $this->expandPropertySet($this->propertiesFieldConfig);
            return $value;
        }

        if (is_array($value)) {
            return new PropertiesModel([
                'properties' => $value,
                'propertiesFieldConfig' => $this->expandPropertySet($this->propertiesFieldConfig),
                'element' => $element,
                'field' => $this,
            ]);
        }


        return new PropertiesModel(['propertiesFieldConfig' => $this->expandPropertySet($this->propertiesFieldConfig)]);
    }


    /**
     * @inheritDoc
     */
    public function serializeValue($value, ElementInterface $element = null): array
    {
        return $value->properties ?? [];
    }

    /**
     * @inheritDoc
     */
    protected function inputHtml(mixed $value, ?ElementInterface $element, bool $inline): string
    {

        return Craft::$app->getView()->renderTemplate('_properties-field/_properties-input', [
            'field' => $this,
            'properties' => $value->properties,
            'propertiesFieldConfig' => $this->expandPropertySet($value->propertiesFieldConfig),
            'element' => $element,
            'settings' => PropertiesFieldPlugin::getInstance()->getSettings(),
        ]);
    }

    /**
     * @inheritDoc
     */
    public function getElementValidationRules(): array
    {
        $rules = parent::getElementValidationRules();
        $rules[] = ['validateProperties', 'on' => [Entry::SCENARIO_LIVE]];


        return $rules;
    }

    /**
     * Check for required properties
     *
     * @param ElementInterface $element
     * @return void
     * @throws InvalidFieldException
     */
    public function validateProperties(ElementInterface $element)
    {
        $data = $element->getFieldValue($this->handle);
        foreach ($this->propertiesFieldConfig as $property) {
            $value = $data->properties[$property['handle']] ?? null;
            if ($property['required'] && !$value) {
                $element->addError($this->handle, $property['name'] . ': ' . Craft::t('_properties-field', 'cannot be blank.'));
            }
        }
    }

    /**
     * @inheritDoc
     */
    protected function searchKeywords(mixed $value, ElementInterface $element): string
    {
        return StringHelper::toString($value, ' ');
    }


    /* --------------------------------------
     * RELATIONAL FIELD INTERFACE
     * TODO: Check for correct values
     * --------------------------------------
     */

    /**
     * @inheritDoc
     */
    public function localizeRelations(): bool
    {
        return false;
    }

    /**
     * @inheritDoc
     */
    public function forceUpdateRelations(ElementInterface $element): bool
    {
        return true;
    }

    /**
     * @inheritDoc
     */
    public function getRelationTargetIds(ElementInterface $element): array
    {
        $properties = $element->getFieldValue($this->handle)->getNormalizedProperties();
        $ids = [];
        foreach ($properties as $property) {
            // The types that provide either a single id or an array of IDs
            if (in_array($property['type'], ['entry', 'entries', 'asset', 'assets'], true) && !empty($property['value'])) {
                if (is_string($property['value'])) {
                    $ids[] = $property['value'];
                } else {
                    $ids = array_merge($ids, $property['value']);
                }
            }
        }

        return $ids;
    }

    private function expandPropertySet($propertiesFieldConfig)
    {
        $newConfig = [];
        foreach ($propertiesFieldConfig as $i => $config) {
            if ($config['type'] == 'set') {
                $setEntry = Entry::find()
                    ->slug($config['options'])
                    ->one();
                if ($setEntry) {
                    $extraConfigs = $setEntry->propertiesConfig;
                    foreach ($extraConfigs as $extraConfig) {
                        $newConfig[] = [
                            'name' => $extraConfig['name'] ?? '',
                            'handle' => $extraConfig['handle'] ?? '',
                            'instructions' => $extraConfig['instructions'] ?? '',
                            'required' => $extraConfig['required'] ?? false,
                            'type' => $extraConfig['type'] ?? '',
                            'options' => $extraConfig['options'] ?? '',
                            'fieldConfig' => $extraConfig['fieldConfig'] ?? '',
                        ];
                    }
                }
            } else {
                $newConfig[] = $config;
            }
        }

        return $newConfig;
    }

    public function getPropertyConfigByHandle(string $handle): mixed
    {

        foreach ($this->propertiesFieldConfig as $propertyConfig) {
            if ($propertyConfig['handle'] === $handle) {
                return $propertyConfig;
            }
        }

        return null;
    }
}
