<?php

namespace wsydney76\propertiesfield\fields;

use Craft;
use craft\base\ElementInterface;
use craft\base\Field;
use craft\base\RelationalFieldInterface;
use craft\elements\Entry;
use craft\errors\InvalidFieldException;
use craft\helpers\Cp;
use craft\helpers\StringHelper;
use Exception;
use wsydney76\propertiesfield\events\DefineSearchKeywordsEvent;
use wsydney76\propertiesfield\models\PropertiesModel;
use wsydney76\propertiesfield\PropertiesFieldPlugin;
use yii\db\Schema;
use function array_merge;
use function is_array;
use function is_string;

/**
 * Properties field type
 */
class Properties extends Field implements RelationalFieldInterface
{
    public const EVENT_DEFINE_SEARCH_KEYWORDS = 'defineSearchKeywords';

    public array $propertiesFieldConfig = [];
    public string $color = '';

    public static function displayName(): string
    {
        return Craft::t('_properties-field', 'Properties');
    }

    public static function icon(): string
    {
        return 'table-list';
    }

    /**
     * @inheritDoc
     */
    public static function phpType(): string
    {
        return PropertiesModel::class;
    }

    public static function dbType(): array|string|null
    {
        // Replace with the appropriate data type this field will store in the database,
        // or `null` if the field is managing its own data storage.
        return Schema::TYPE_JSON;
    }

    protected function dbTypeForValueSql(): array|string|null
    {
        return parent::dbTypeForValueSql(); // TODO: Change the autogenerated stub
    }

    public function attributeLabels(): array
    {
        return array_merge(parent::attributeLabels(), [
            // ...
        ]);
    }

    protected function defineRules(): array
    {
        return array_merge(parent::defineRules(), [

            ['propertiesFieldConfig', 'checkConfig'],

        ]);
    }

    public function checkConfig($attribute): void
    {
        $handles = [];
        foreach ($this->propertiesFieldConfig as $i => $fieldConfig) {

            if (empty($fieldConfig['name'])) {
                $this->addError($attribute, Craft::t('_properties-field', $i + 1 . ': Name cannot be blank.'));
            } else {
                if (empty($fieldConfig['handle'])) {
                    // If handle is empty, use name as handle
                    $fieldConfig['handle'] = StringHelper::toHandle($fieldConfig['name']);
                    $this->propertiesFieldConfig[$i]['handle'] = $fieldConfig['handle'];
                }
            }

            if (empty($fieldConfig['handle'])) {
                $this->addError($attribute, Craft::t('_properties-field', $i + 1 . ': Handle cannot be blank.'));
            } elseif (!(bool)preg_match('/^[a-zA-Z][a-zA-Z0-9_]*$/', $fieldConfig['handle'])) {
                $this->addError($attribute, Craft::t('_properties-field', $i + 1 . ': Is not a valid handle.'));
            } elseif (in_array($fieldConfig['handle'], $handles, true)) {
                $this->addError($attribute, Craft::t('_properties-field', $i + 1 . ': Handle must be unique.'));
            } else {
                $handles[] = $fieldConfig['handle'];
            }


            if (!empty($fieldConfig['fieldConfig'])) {
                // Check if fieldConfig is a valid JSON string
                $isValidJson = json_decode($fieldConfig['fieldConfig'], true);
                if ($isValidJson === null) {
                    $this->addError($attribute, Craft::t('_properties-field', $i + 1 . ': Field Config must be a valid JSON string.'));
                }
            }
        }
    }

    /**
     * The HTML for the field settings in the control panel.
     *
     * @return string|null
     */
    public function getSettingsHtml(): ?string
    {
        $settings = PropertiesFieldPlugin::getInstance()->getSettings();

        $options = array_merge($settings->propertiesConfig, $settings->extraPropertiesConfig);
        return
            Cp::colorSelectFieldHtml([
                'label' => Craft::t('_properties-field', 'Base Color'),
                'name' => 'color',
                'value' => $this->color,
                'id' => 'color',
                'instructions' => Craft::t('_properties-field', 'The background color for group headers and property labels.'),
            ]) .
            Cp::editableTableFieldHtml([
                'label' => Craft::t('_properties-field', 'Properties Configuration'),
                'instructions' => Craft::t('_properties-field', 'Options for select: one option per line, in the format value:label<br>Options for entries/assets: section/volume handles, comma separated'),
                'id' => 'propertiesFieldConfig',
                'name' => 'propertiesFieldConfig',
                'addRowLabel' => Craft::t('_properties-field', 'Add a property'),
                'allowAdd' => true,
                'allowReorder' => true,
                'allowDelete' => true,
                'warning' => Craft::t('_properties-field', 'Renaming an existing option or changing its type may result in data loss or runtime errors without migrating existing content.'),
                'cols' => [
                    'name' => ['heading' => Craft::t('_properties-field', 'Name'), 'type' => 'singleline'],
                    'handle' => ['heading' => Craft::t('_properties-field', 'Handle'), 'type' => 'singleline', 'class' => 'code'],
                    'instructions' => ['heading' => Craft::t('_properties-field', 'Instructions'), 'type' => 'singleline'],
                    'required' => ['heading' => Craft::t('_properties-field', 'Required'), 'type' => 'lightswitch'],
                    'searchable' => ['heading' => Craft::t('_properties-field', 'Search'), 'type' => 'lightswitch'],
                    'type' => [
                        'heading' => Craft::t('_properties-field', 'Type'),
                        'type' => 'select',
                        'class' => 'code',
                        'options' => $options,
                        'width' => '10%',
                    ],
                    'options' => ['heading' => Craft::t('_properties-field', 'Options'), 'type' => 'multiline'],
                    'fieldConfig' => ['heading' => Craft::t('_properties-field', 'Field Config'), 'type' => 'multiline'],

                ],
                'rows' => $this->propertiesFieldConfig,
                'errors' => $this->getErrors('propertiesFieldConfig'),
                'data' => ['error-key' => 'options'],
            ]);
    }

    /**
     * @inheritDoc
     */
    public function normalizeValue(mixed $value, ?ElementInterface $element): mixed
    {
        if ($value instanceof PropertiesModel) {
            $value->propertiesFieldConfig = $this->expandPropertySet($this->propertiesFieldConfig);
            return $value;
        }

        if (is_array($value)) {
            return new PropertiesModel([
                'properties' => $value,
                'propertiesFieldConfig' => $this->expandPropertySet($this->propertiesFieldConfig),
                'element' => $element,
                'field' => $this,
            ]);
        }


        return new PropertiesModel(['propertiesFieldConfig' => $this->expandPropertySet($this->propertiesFieldConfig)]);
    }


    /**
     * @inheritDoc
     */
    public function serializeValue($value, ElementInterface $element = null): array
    {
        return $value->properties ?? [];
    }

    /**
     * @inheritDoc
     */
    protected function inputHtml(mixed $value, ?ElementInterface $element, bool $inline): string
    {

        return Craft::$app->getView()->renderTemplate('_properties-field/_properties-input', [
            'field' => $this,
            'properties' => $value->properties,
            'propertiesFieldConfig' => $this->expandPropertySet($value->propertiesFieldConfig),
            'element' => $element,
            'settings' => PropertiesFieldPlugin::getInstance()->getSettings(),
        ]);
    }

    /**
     * @inheritDoc
     */
    public function getElementValidationRules(): array
    {
        $rules = parent::getElementValidationRules();
        $rules[] = ['validateProperties', 'on' => [Entry::SCENARIO_LIVE]];


        return $rules;
    }

    /**
     * Validate properties
     * TODO: Check if Craft's built-in validations can be used
     *
     * @param ElementInterface $element
     * @return void
     * @throws InvalidFieldException
     */
    public function validateProperties(ElementInterface $element)
    {
        $data = $element->getFieldValue($this->handle);
        $settings = PropertiesFieldPlugin::getInstance()->getSettings();

        // \Craft::dd($settings->getAllPropertiesConfig());

        foreach ($this->propertiesFieldConfig as $property) {
            // Using try/catch to avoid errors when the property is not set or mal formatted
            $callbacks = $settings->getAllPropertiesConfig()[$property['type']]['validate'] ?? null;
            try {
                if ($callbacks) {
                    foreach ($callbacks as $callback) {
                        call_user_func($callback, $element, $this, $property, $data->properties[$property['handle']] ?? null);
                    }
                }
            } catch (Exception $e) {
                if (Craft::$app->config->general->devMode) {
                    \Craft::dd($e->getMessage());
                }
                Craft::error($e->getMessage(), __METHOD__);
            }
        }
    }

    /**
     * @inheritDoc
     * @throws InvalidFieldException
     */
    protected function searchKeywords(mixed $value, ElementInterface $element): string
    {

        $data = $element->getFieldValue($this->handle);
        $keywords = [];

        foreach ($data->getNormalizedProperties() as $property) {
            switch ($property['type']) {
                case 'text':
                case 'textarea':
                case 'email':
                case 'number':
                    $keywords[] = $property['value'];
                    break;
                case 'select':
                    $keywords[] = $property['normalizedValue']->label ?? '';
                    break;
                case 'entry':
                case 'asset':
                    if ($property['normalizedValue']) {
                        $keywords[] = $property['normalizedValue']->title ?? '';
                    }
                    break;
                case 'entries':
                case 'assets':
                    if ($property['normalizedValue']) {
                        foreach ($property['normalizedValue'] as $entry) {
                            $keywords[] = $entry->title ?? '';
                        }
                    }
                    break;
                case 'extendedBoolean':
                    $keywords[] = $property['value']['comment'] ?? '';
                    $keywords[] = $property['name'];
                    break;
                case 'boolean':
                    $keywords[] = $property['name'];
                    break;
                case 'date':
                case 'groupHeader':
                case 'set':
                    // Do nothing
                    break;
                default:
                    if ($this->hasEventHandlers(self::EVENT_DEFINE_SEARCH_KEYWORDS)) {
                        $event = new DefineSearchKeywordsEvent([
                            'element' => $element,
                            'field' => $this,
                            'property' => $property,
                        ]);
                        $this->trigger(self::EVENT_DEFINE_SEARCH_KEYWORDS, $event);
                        $keywords[] = $event->keywords;
                    }
                    break;
            }
        }

        return implode(' ', $keywords);
    }


    /* --------------------------------------
     * RELATIONAL FIELD INTERFACE
     * TODO: Check for correct values
     * --------------------------------------
     */

    /**
     * @inheritDoc
     */
    public function localizeRelations(): bool
    {
        return false;
    }

    /**
     * @inheritDoc
     */
    public function forceUpdateRelations(ElementInterface $element): bool
    {
        return true;
    }

    /**
     * @inheritDoc
     */
    public function getRelationTargetIds(ElementInterface $element): array
    {
        $properties = $element->getFieldValue($this->handle)->getNormalizedProperties();
        $ids = [];
        foreach ($properties as $property) {
            // The types that provide either a single id or an array of IDs
            if (in_array($property['type'], ['entry', 'entries', 'asset', 'assets'], true) && !empty($property['value'])) {
                if (is_string($property['value'])) {
                    $ids[] = $property['value'];
                } else {
                    $ids = array_merge($ids, $property['value']);
                }
            }
        }

        return $ids;
    }

    private function expandPropertySet($propertiesFieldConfig)
    {
        $newConfig = [];
        foreach ($propertiesFieldConfig as $i => $config) {
            if ($config['type'] == 'set') {
                $setEntry = Entry::find()
                    ->slug($config['options'])
                    ->one();
                if ($setEntry) {
                    $extraConfigs = $setEntry->propertiesConfig;
                    foreach ($extraConfigs as $extraConfig) {
                        $newConfig[] = [
                            'name' => $extraConfig['name'] ?? '',
                            'handle' => $extraConfig['handle'] ?? '',
                            'instructions' => $extraConfig['instructions'] ?? '',
                            'required' => $extraConfig['required'] ?? false,
                            'searchable' => $extraConfig['required'] ?? false,
                            'type' => $extraConfig['type'] ?? '',
                            'options' => $extraConfig['options'] ?? '',
                            'fieldConfig' => $extraConfig['fieldConfig'] ?? '',
                        ];
                    }
                }
            } else {
                $newConfig[] = $config;
            }
        }

        return $newConfig;
    }

    public function getPropertyConfigByHandle(string $handle): mixed
    {

        foreach ($this->propertiesFieldConfig as $propertyConfig) {
            if ($propertyConfig['handle'] === $handle) {
                return $propertyConfig;
            }
        }

        return null;
    }

    public function validateRequired(ElementInterface $element, Properties $field, array $property, mixed $value): void
    {
        if ($property['required'] && !$value) {
            $element->addError($field->handle, $field->name . '/' . $property['name'] . ': ' . Craft::t('_properties-field', 'cannot be blank.'));
        }
    }

    public function validateNumber(ElementInterface $element, Properties $field, array $property, mixed $value): void
    {
        if (!$value) {
            return;
        }

        $fieldConfig = json_decode($property['fieldConfig'], true);

        if (isset($fieldConfig['min'])) {
            if ($value < $fieldConfig['min']) {
                $element->addError($field->handle, $field->name . '/' . $property['name'] . ': ' . Craft::t('_properties-field', 'must be greater than or equal to {min}.', ['min' => $fieldConfig['min']]));
            }
        }
        if (isset($fieldConfig['max'])) {
            if ($value > $fieldConfig['max']) {
                $element->addError($field->handle, $field->name . '/' . $property['name'] . ': ' . Craft::t('_properties-field', 'must be less than or equal to {max}.', ['max' => $fieldConfig['max']]));
            }
        }
    }

    public function validateEmail(ElementInterface $element, Properties $field, array $property, mixed $value): void
    {
        if (!$value) {
            return;
        }

        if (!filter_var($value, FILTER_VALIDATE_EMAIL)) {
            $element->addError($field->handle, $field->name . '/' . $property['name'] . ': ' . Craft::t('_properties-field', 'must be a valid email address.'));
        }
    }

    public function validateExtendedBoolean(ElementInterface $element, Properties $field, array $property, mixed $value): void
    {
        if ($property['required'] && !$value['comment']) {
            $element->addError($field->handle, $field->name . '/' . $property['name'] . ': ' . Craft::t('_properties-field', 'Comment cannot be blank.'));
        }
    }

    public function validateDimension(ElementInterface $element, Properties $field, array $property, mixed $value): void
    {
        if ($property['required'] && !$value['quantity']) {
            $element->addError($field->handle, $field->name . '/' . $property['name'] . ': ' . Craft::t('_properties-field', 'Quantity cannot be blank.'));
        }

    }
}
